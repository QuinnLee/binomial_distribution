<!DOCCTYPE html>
<meta charset="utf-8">
<body>
  <div class='distribution'></div>

  <p>
    <label for="count" style="display: inline-block; width: 240px; text-align: right">
      count = <span id="count-value">â€¦</span>
    </label>
    <input type="range" min="1" max="100" id="count">
  </p>

  <p>
    <label for="area" style="display: inline-block; width: 240px; text-align: right"></label>
    <input type="range" min="0" max="1" step='0.05' id="area">
  </p>

  <button id='start'> Start </button>

  <h1> Summary </h1>
  <h2 id='trialCount'></h2>
  <h2 id='currentCount'></h2>
  <h2 id='expectedCount'></h2>

  <script src="./d3.min.js"></script>
  <script>
  var width = 200,
    height = 200;

  var factorial = (
    function() {
      var cache = {},
      fn = function(n) {
        if (n === 0) {
          return 1;
        } else if (cache[n]) {
          return cache[n];
        }
      return cache[n] = n * fn(n -1);
      };
    return fn;
  }());

  var distribution = d3.select(".distribution").append("svg")
    .attr("width", width)
    .attr("height", height)

  var square = distribution.append('rect')
    .attr("x", 125)
    .attr("y", 125)
    .style("fill", "grey")
    .attr("height", 250)
    .attr("width", 250);

  var graph_margin = {
    top: 20,
    right: 70,
    bottom: 20,
    left: 70
    },
    graph_width = 600 - graph_margin.left - graph_margin.right,
    graph_height = 300 - graph_margin.top - graph_margin.bottom;

  var pdf = d3.select("body").append("svg")
    .attr("width", graph_width + graph_margin.left + graph_margin.right)
    .attr("height", graph_height + graph_margin.top + graph_margin.bottom)
  .append('g')
    .attr("transform", "translate(" + graph_margin.left + "," + graph_margin.top + ")");

  var x = d3.scale.linear()
    .range([0, graph_width]);

  var y = d3.scale.linear()
    .range([graph_height, 0]);

  var xAxis = d3.svg.axis()
    .scale(x)
    .orient("bottom")
    .tickFormat(d3.format(",d"));

  var yAxis = d3.svg.axis()
    .scale(y)
    .orient("left")
    .ticks(11);

  var yAxisRight = d3.svg.axis()
    .scale(y)
    .orient("right")
    .ticks(11);

  var lineGraph = pdf.append('path');

  var lineCDFGraph = pdf.append('path');

  var line = d3.svg.line()
    .interpolate("basis")
    .x(function(d) { return x(d.i) })
    .y(function(d) { return y(d.p) });

  var lineCDF = d3.svg.line()
    .interpolate("basis")
    .x(function(d,i) { return x(i) })
    .y(function(d) { return y(d) });

  var xAxisPDFLabel = pdf.append('g')
    .attr("transform", "translate(0,"+graph_height+")");

  var yAxisPDFLabel = pdf.append("g")

  var yAxisCDFLabel = pdf.append("g")
    .attr("transform", "translate(" + graph_width + " ,0)")

  var dotCount = 0;
  var trialCount = 0;

  updateCount(100);
  updateArea(0.5);

  d3.select('#count').on('input', function(){
    updateCount(parseInt(this.value));
  });

  d3.select('#area').on('input', function(){
    updateArea(parseFloat(this.value));
    d3.timer(updateCircles, 1000);
  });

  d3.select('#start').on('click', function() {
    distribution.selectAll('circle').remove()
    var dotCount = d3.select('#count').property('value');
    var sample = uniformRandomSampler(width, height, dotCount);

    d3.timer(function() {
      var s = sample();
      if (!s) return true;
      distribution.append("circle")
          .attr("cx", s[0])
          .attr("cy", s[1])
          .attr("r", 0)
          .data([{x: s[0], y: s[1]}])
        .transition()
          .duration(400)
          .attr("r", 6)
          .attr("fill", function (d) {return updateCircleColor(d)})
    });
  });


  function updateCircleColor(d) {
    rectData = distribution.select('rect').datum()
    if(d.x >= rectData.topX && d.x <= rectData.botX && d.y >= rectData.topY &&  d.y <= rectData.botY){
      return 'blue'
    }else {
      return 'black'
    }
  }


  function updateCircles() {
    distribution.selectAll('circle')
      .attr("fill", function (d) {return updateCircleColor(d)})
  }

  function updateCount(count) {
    d3.select('#count-value').text(count);
    d3.select('#count').property('value', count);

    setLineGraph()
  }

  function updateArea(area) {
    d3.select('#area').property('value', area);
    length = width * area;
    center = (width - length) / 2.0 ;

    distribution.select("rect")
      .attr("x", center)
      .attr("y", center)
      .data([{
              probablity: Math.pow(parseFloat(area), 2),
              area: Math.pow(length, 2),
              topX: center,
              topY: center,
              botX: center + length,
              botY: center + length
            }])
      .attr("height", length)
      .attr("width", length);

    setLineGraph()
  }

  function setLineGraph() {
    var area = d3.select('#area').property('value');
    var count = d3.select('#count').property('value');
    var pdf = binomialDistributionArray( Math.pow(parseFloat(area), 2), count)

    var cdf = []

    pdf.reduce(function(p,c,i){
      cdf[i] = parseFloat((c.p)+ p)
      return parseFloat((c.p)+ p)
    }, 0)
    
    x.domain([0, count])
    y.domain(d3.extent(pdf,function(d) { return d.p }))

    lineGraph.transition()
      .attr('d', line(pdf))
      .attr('fill', 'none')
      .attr("stroke-width", 1)
      .attr("stroke", "black")

    xAxisPDFLabel.call(xAxis);

    yAxisPDFLabel.call(yAxis);

    y.domain([0.0, 1.0]).clamp()
    x.domain([0, count])

    lineCDFGraph.transition()
      .attr('d', lineCDF(cdf))
      .attr('fill', 'none')
      .attr("stroke-width", 1)
      .attr("stroke", "black");

    yAxisCDFLabel.call(yAxisRight);
  }

  function updateTrialCount() {
  }

  function resetTrialCount() {
  }

  function setExpectedCount(probablity, count) {
  }

  function setCurrentCount() {
  }

  function uniformRandomSampler(width, height, numSamplesMax) {
    var numSamples = 0;
    return function() {
      if (++numSamples > numSamplesMax) return;
      return [Math.random() * width, Math.random() * height];
    };
  }

  function binomialDistributionArray(p, n) {
    binomialMassArray = []
    for(var i=0; i <= n; i++){
      binomialMassArray.push(
        {
          'p': (factorial(n)/(factorial(n-i)*factorial(i))) * Math.pow(p,i) * Math.pow((1-p),n-i),
          'i': i
        }
      )
    }
    return binomialMassArray
  }

  </script>
</body>
